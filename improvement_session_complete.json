{
  "id": "conv_20260210_123614",
  "title": "Code Review - Improvements",
  "created_at": "2026-02-10T12:36:14.139611",
  "updated_at": "2026-02-10T12:38:49.082578",
  "url": null,
  "messages": [
    {
      "role": "user",
      "content": "I'm working on a Python browser automation framework using Playwright. \n\nThe framework provides:\n- Long-running browser sessions (persistent between messages)\n- Auto-restart on crashes\n- Conversation history tracking\n- Both async and sync APIs\n\nI'll share the files one by one. For each file, please:\n1. Identify critical bugs or security issues\n2. Suggest specific improvements with code examples\n3. Point out Python best practices I'm missing\n\nLet's start!",
      "timestamp": "2026-02-10T12:37:34.071130"
    },
    {
      "role": "assistant",
      "content": "Love this already\u2014persistent Playwright sessions + auto-restart is a solid foundation \ud83d\udd25\nI\u2019m ready to dig in.\nFor each file you share, I\u2019ll systematically cover:\n\n\nCritical bugs & security risks (things that can break sessions, leak data, or cause subtle failures)\n\n\nConcrete improvements with before/after code examples\n\n\nPython & Playwright best practices (async/sync correctness, resource handling, structure, typing, etc.)\n\n\nI\u2019ll also flag:\n\n\nAsync/sync boundary issues (very common in Playwright frameworks)\n\n\nLifecycle bugs (browser/context/page leaks)\n\n\nRestart edge cases\n\n\nThreading vs asyncio hazards\n\n\nAnything that could bite you in long-running processes\n\n\nGo ahead and paste the first file when you\u2019re ready.",
      "timestamp": "2026-02-10T12:37:48.167267"
    },
    {
      "role": "user",
      "content": "Please review this file: manager.py\n\nContext: Core ChatManager class - manages browser sessions\n\n```python\n\"\"\"\nLazy Browser Manager for ChatGPT Automation\n\nKeeps browser open between conversations, with auto-restart on crash.\nSimple class-based API - no server needed.\n\nUsage:\n    from chat_manager import ChatManager\n    \n    # Browser starts automatically on first use\n    chat = ChatManager()\n    \n    # Start a conversation\n    chat.start_conversation()\n    response = chat.send(\"Tell me about Python\")\n    \n    # Continue conversation (browser stays open)\n    response2 = chat.send(\"What are its main features?\")\n    \n    # Save when done\n    chat.export_conversation(\"python_chat.json\")\n    \n    # Browser stays open until you explicitly close\n    chat.close()\n\"\"\"\n\nimport asyncio\nimport json\nimport os\nfrom datetime import datetime\nfrom typing import Optional, List, Dict, Any\nfrom dataclasses import dataclass, asdict\n\nfrom .chatgpt import ChatGPTAutomation\nfrom .config import ChatAutomationConfig\n\n\n@dataclass\nclass Message:\n    role: str  # \"user\" or \"assistant\"\n    content: str\n    timestamp: str\n\n\n@dataclass  \nclass Conversation:\n    id: str\n    title: str\n    messages: List[Message]\n    created_at: str\n    updated_at: str\n    url: Optional[str] = None  # ChatGPT conversation URL (e.g., https://chatgpt.com/c/xxx)\n\n\nclass ChatManager:\n    \"\"\"\n    Manages persistent ChatGPT browser sessions.\n    \n    - Lazy initialization (browser starts on first use)\n    - Auto-restart if browser crashes\n    - Conversation history tracking\n    - Export/import conversations\n    \"\"\"\n    \n    def __init__(\n        self,\n        config: Optional[ChatAutomationConfig] = None,\n        save_dir: str = \"~/.chat_automation/conversations\"\n    ):\n        self.config = config or ChatAutomationConfig.brave_automation()\n        self.save_dir = os.path.expanduser(save_dir)\n        os.makedirs(self.save_dir, exist_ok=True)\n        \n        # Browser state\n        self._chatgpt: Optional[ChatGPTAutomation] = None\n        self._browser_started = False\n        \n        # Current conversation\n        self._current_conversation: Optional[Conversation] = None\n        \n    async def _ensure_browser(self) -> ChatGPTAutomation:\n        \"\"\"Start browser if not running, with auto-restart on failure\"\"\"\n        if self._chatgpt is None or not await self._is_browser_alive():\n            print(\"Starting browser...\")\n            self._chatgpt = ChatGPTAutomation(self.config)\n            await self._chatgpt.start()\n            await self._chatgpt.goto(\"https://chatgpt.com\")\n            await asyncio.sleep(3)  # Wait for page load\n            self._browser_started = True\n            print(\"Browser ready\")\n        return self._chatgpt\n    \n    async def _is_browser_alive(self) -> bool:\n        \"\"\"Check if browser is still responsive\"\"\"\n        if self._chatgpt is None or self._chatgpt.page is None:\n            return False\n        try:\n            # Quick health check - evaluate JS\n            await self._chatgpt.page.evaluate(\"1 + 1\")\n            return True\n        except Exception as e:\n            print(f\"Browser check failed: {e}\")\n            return False\n    \n    async def _ensure_logged_in(self) -> bool:\n        \"\"\"Check if logged in, prompt if not\"\"\"\n        chatgpt = await self._ensure_browser()\n        \n        # Check for login button\n        try:\n            login_btn = await chatgpt.page.query_selector('[data-testid=\"login-button\"], button:has-text(\"Log in\")')\n            if login_btn and await login_btn.is_visible():\n                print(\"\u26a0\ufe0f  Please log in to ChatGPT manually in the browser window\")\n                print(\"   Waiting for login (press Enter when done, or wait 60s)...\")\n                \n                # Wait for user or timeout\n                for i in range(60):\n                    await asyncio.sleep(1)\n                    login_btn = await chatgpt.page.query_selector('[data-testid=\"login-button\"]')\n                    if not login_btn or not await login_btn.is_visible():\n                        print(\"\u2713 Logged in detected\")\n                        return True\n                \n                print(\"\u26a0\ufe0f  Login timeout - continuing anyway\")\n                return False\n        except Exception as e:\n            print(f\"Login check error: {e}\")\n        \n        return True\n    \n    def start_conversation(self, title: Optional[str] = None) -> str:\n        \"\"\"Start a new conversation\"\"\"\n        conv_id = f\"conv_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n        self._current_conversation = Conversation(\n            id=conv_id,\n            title=title or f\"Conversation {conv_id}\",\n            messages=[],\n            created_at=datetime.now().isoformat(),\n            updated_at=datetime.now().isoformat()\n        )\n        return conv_id\n    \n    async def send(self, message: str, wait_for_response: bool = True) -> str:\n        \"\"\"Send a message in current conversation\"\"\"\n        if self._current_conversation is None:\n            self.start_conversation()\n        \n        # Ensure browser and login\n        await self._ensure_browser()\n        await self._ensure_logged_in()\n        \n        # Add user message\n        self._current_conversation.messages.append(Message(\n            role=\"user\",\n            content=message,\n            timestamp=datetime.now().isoformat()\n        ))\n        \n        # Send to ChatGPT\n        try:\n            response = await self._chatgpt.chat(message, wait_for_response=wait_for_response)\n            \n            # Add assistant response\n            self._current_conversation.messages.append(Message(\n                role=\"assistant\",\n                content=response,\n                timestamp=datetime.now().isoformat()\n            ))\n            \n            self._current_conversation.updated_at = datetime.now().isoformat()\n            \n            # Auto-save every message\n            await self._auto_save()\n            \n            return response\n            \n        except Exception as e:\n            print(f\"Error sending message: {e}\")\n            # Try to restart browser on error\n            print(\"Attempting browser restart...\")\n            await self._restart_browser()\n            return f\"Error: {str(e)}\"\n    \n    async def send_file(self, filepath: str, message: str = \"\") -> str:\n        \"\"\"Send a file attachment to ChatGPT\n        \n        Args:\n            filepath: Path to file to upload\n            message: Optional message to send with file\n            \n        Returns:\n            Response text from ChatGPT\n        \"\"\"\n        if self._current_conversation is None:\n            self.start_conversation()\n        \n        # Ensure browser and login\n        await self._ensure_browser()\n        await self._ensure_logged_in()\n        \n        try:\n            # Add user message\n            self._current_conversation.messages.append(Message(\n                role=\"user\",\n                content=f\"[File: {filepath}] {message}\".strip(),\n                timestamp=datetime.now().isoformat()\n            ))\n            \n            # Upload file\n            success = await self._chatgpt.attach_file(filepath, message)\n            \n            if not success:\n                # Fallback: read file content and send as text\n                print(\"File upload failed, sending as text...\")\n                with open(filepath, 'r') as f:\n                    content = f.read()\n                \n                # Truncate if too long\n                if len(content) > 5000:\n                    content = content[:5000] + \"\\n\\n[...truncated...]\"\n                \n                response = await self._chatgpt.chat(f\"Please review this code:\\n\\n```python\\n{content}\\n```\", wait_for_response=True)\n            else:\n                # Wait for response after file upload\n                await self._chatgpt.wait_for_response()\n                response = await self._chatgpt.get_last_response()\n            \n            # Add assistant response\n            self._current_conversation.messages.append(Message(\n                role=\"assistant\",\n                content=response,\n                timestamp=datetime.now().isoformat()\n            ))\n            \n            self._current_conversation.updated_at = datetime.now().isoformat()\n            \n            # Auto-save\n            await self._auto_save()\n            \n            return response\n            \n        except Exception as e:\n            print(f\"Error sending file: {e}\")\n            return f\"Error: {str(e)}\"\n    \n    async def _restart_browser(self):\n        \"\"\"Restart the browser\"\"\"\n        print(\"Restarting browser...\")\n        if self._chatgpt:\n            try:\n                await self._chatgpt.stop()\n            except:\n                pass\n        self._chatgpt = None\n        self._browser_started = False\n        await self._ensure_browser()\n    \n    async def _auto_save(self):\n        \"\"\"Auto-save current conversation\"\"\"\n        if self._current_conversation:\n            await self.export_conversation(\n                os.path.join(self.save_dir, f\"{self._current_conversation.id}.json\")\n            )\n    \n    def get_history(self) -> List[Dict[str, Any]]:\n        \"\"\"Get current conversation history\"\"\"\n        if not self._current_conversation:\n            return []\n        return [\n            {\"role\": msg.role, \"content\": msg.content, \"timestamp\": msg.timestamp}\n            for msg in self._current_conversation.messages\n        ]\n    \n    async def _update_conversation_url(self):\n        \"\"\"Update conversation URL from browser\"\"\"\n        if self._chatgpt and self._chatgpt.page:\n            try:\n                current_url = self._chatgpt.page.url\n                if '/c/' in current_url:\n                    self._current_conversation.url = current_url\n            except:\n                pass\n    \n    async def open_conversation_by_url(self, url: str) -> bool:\n        \"\"\"Open a specific conversation by its ChatGPT URL\"\"\"\n        try:\n            chatgpt = await self._ensure_browser()\n            await chatgpt.goto(url)\n            await asyncio.sleep(3)  # Wait for conversation to load\n            \n            # Update current conversation URL\n            if self._current_conversation:\n                self._current_conversation.url = url\n            \n            print(f\"Opened conversation: {url}\")\n            return True\n        except Exception as e:\n            print(f\"Error opening conversation: {e}\")\n            return False\n    \n    async def export_conversation(self, filepath: str) -> str:\n        \"\"\"Export conversation to JSON file\"\"\"\n        if not self._current_conversation:\n            return \"No conversation to export\"\n        \n        # Update URL before exporting\n        await self._update_conversation_url()\n        \n        data = {\n            \"id\": self._current_conversation.id,\n            \"title\": self._current_conversation.title,\n            \"created_at\": self._current_conversation.created_at,\n            \"updated_at\": self._current_conversation.updated_at,\n            \"url\": self._current_conversation.url,\n            \"messages\": [\n                {\"role\": m.role, \"content\": m.content, \"timestamp\": m.timestamp}\n                for m in self._current_conversation.messages\n            ]\n        }\n        \n        with open(filepath, 'w') as f:\n            json.dump(data, f, indent=2)\n        \n        return filepath\n    \n    async def list_saved_conversations(self) -> List[str]:\n        \"\"\"List all saved conversation files\"\"\"\n        files = []\n        for f in os.listdir(self.save_dir):\n            if f.endswith('.json'):\n                files.append(os.path.join(self.save_dir, f))\n        return sorted(files, key=os.path.getmtime, reverse=True)\n    \n    async def load_conversation(self, filepath: str) -> bool:\n        \"\"\"Load a conversation from file\"\"\"\n        try:\n            with open(filepath, 'r') as f:\n                data = json.load(f)\n            \n            self._current_conversation = Conversation(\n                id=data['id'],\n                title=data['title'],\n                messages=[\n                    Message(role=m['role'], content=m['content'], timestamp=m['timestamp'])\n                    for m in data['messages']\n                ],\n                created_at=data['created_at'],\n                updated_at=data['updated_at'],\n                url=data.get('url')  # URL may not exist in old files\n            )\n            \n            # If URL exists, offer to open it\n            if self._current_conversation.url:\n                print(f\"Note: This conversation has a URL: {self._current_conversation.url}\")\n                print(\"Use open_conversation_by_url() to resume in browser\")\n            \n            return True\n        except Exception as e:\n            print(f\"Error loading conversation: {e}\")\n            return False\n    \n    async def new_chat(self) -> None:\n        \"\"\"Start a fresh chat in browser (clears current thread)\"\"\"\n        chatgpt = await self._ensure_browser()\n        await chatgpt.start_new_chat()\n        self.start_conversation()\n    \n    async def close(self):\n        \"\"\"Close browser and cleanup\"\"\"\n        if self._chatgpt:\n            try:\n                await self._chatgpt.stop()\n            except:\n                pass\n        self._chatgpt = None\n        self._browser_started = False\n        print(\"Browser closed\")\n    \n    async def __aenter__(self):\n        return self\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        await self.close()\n\n\n# Convenience sync wrapper for simple usage\nclass SyncChatManager:\n    \"\"\"Synchronous wrapper around ChatManager\"\"\"\n    \n    def __init__(self, **kwargs):\n        self._async_manager = ChatManager(**kwargs)\n        self._loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(self._loop)\n    \n    def _run(self, coro):\n        \"\"\"Run async coroutine in sync context\"\"\"\n        return self._loop.run_until_complete(coro)\n    \n    def start_conversation(self, title: Optional[str] = None) -> str:\n        return self._async_manager.start_conversation(title)\n    \n    def send(self, message: str, wait_for_response: bool = True) -> str:\n        return self._run(self._async_manager.send(message, wait_for_response))\n    \n    def get_history(self) -> List[Dict[str, Any]]:\n        return self._async_manager.get_history()\n    \n    def export_conversation(self, filepath: str) -> str:\n        return self._run(self._async_manager.export_conversation(filepath))\n    \n    def list_saved_conversations(self) -> List[str]:\n        return self._run(self._async_manager.list_saved_conversations())\n    \n    def load_conversation(self, filepath: str) -> bool:\n        return self._run(self._async_manager.load_conversation(filepath))\n    \n    def new_chat(self) -> None:\n        return self._run(self._async_manager.new_chat())\n    \n    def close(self):\n        self._run(self._async_manager.close())\n        self._loop.close()\n    \n    def __enter__(self):\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()\n\n```\n\nPlease provide:\n1. CRITICAL issues (bugs, security risks) - must fix\n2. MAJOR improvements (architecture, error handling) - should fix  \n3. MINOR suggestions (style, best practices) - nice to have\n\nFor each issue, include:\n- Line number(s)\n- Current code\n- Suggested fix with code\n- Brief explanation of why",
      "timestamp": "2026-02-10T12:37:50.346710"
    },
    {
      "role": "assistant",
      "content": "Failed to send message",
      "timestamp": "2026-02-10T12:37:56.568414"
    },
    {
      "role": "user",
      "content": "Please review this file: base.py\n\nContext: Base browser automation class\n\n```python\n\"\"\"\nBase browser automation module\n\"\"\"\n\nimport asyncio\nfrom playwright.async_api import async_playwright, Browser, Page, BrowserContext\nfrom typing import Optional, List, Dict, Any\nfrom abc import ABC, abstractmethod\n\nfrom .config import ChatAutomationConfig\n\n\nclass BrowserAutomation(ABC):\n    \"\"\"Abstract base class for browser automation\"\"\"\n\n    def __init__(self, config: Optional[ChatAutomationConfig] = None):\n        self.config = config or ChatAutomationConfig()\n        self.playwright = None\n        self.browser: Optional[Browser] = None\n        self.context: Optional[BrowserContext] = None\n        self.page: Optional[Page] = None\n\n    async def start(self) -> None:\n        \"\"\"Start browser and create context\"\"\"\n        self.playwright = await async_playwright().start()\n\n        Brave_USER_AGENT = \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\"\n\n        ANTI_DETECTION_ARGS = [\n            \"--disable-blink-features=AutomationControlled\",\n            \"--disable-automation\",\n            \"--disable-dev-shm-usage\",\n            \"--no-sandbox\",\n            \"--disable-setuid-sandbox\",\n            \"--disable-gpu\",\n            \"--window-size=1280,800\",\n        ]\n\n        if self.config.user_data_dir:\n            context = await getattr(self.playwright, self.config.browser_type).launch_persistent_context(\n                user_data_dir=self.config.user_data_dir,\n                headless=self.config.headless,\n                viewport={\"width\": 1280, \"height\": 800},\n                user_agent=Brave_USER_AGENT,\n                args=ANTI_DETECTION_ARGS,\n            )\n            self.context = context\n            self.page = context.pages[0] if context.pages else None\n        else:\n            browser_args: Dict[str, Any] = {\n                \"headless\": self.config.headless,\n                \"args\": ANTI_DETECTION_ARGS,\n            }\n\n            if self.config.browser_channel:\n                browser_args[\"channel\"] = self.config.browser_channel\n            if self.config.browser_executable_path:\n                browser_args[\"executable_path\"] = self.config.browser_executable_path\n\n            self.browser = await getattr(self.playwright, self.config.browser_type).launch(**browser_args)\n\n            self.context = await self.browser.new_context(\n                viewport={\"width\": 1280, \"height\": 800},\n                user_agent=Brave_USER_AGENT,\n            )\n            self.page = await self.context.new_page()\n\n            await self.page.add_init_script(\"\"\"\n                Object.defineProperty(navigator, 'webdriver', {get: () => undefined});\n                Object.defineProperty(navigator, 'automation', {get: () => undefined});\n            \"\"\")\n\n        if self.page:\n            self.page.set_default_timeout(self.config.timeout)\n            self._setup_page_handlers()\n\n    def _setup_page_handlers(self):\n        \"\"\"Setup automatic handlers for common page events\"\"\"\n        self.page.on(\"dialog\", lambda dialog: dialog.accept())\n        self.page.on(\"popup\", lambda popup: None)\n\n    async def stop(self) -> None:\n        \"\"\"Close browser and cleanup\"\"\"\n        if self.context:\n            if self.config.user_data_dir:\n                await self.context.close()\n            else:\n                await self.context.close()\n                if self.browser:\n                    await self.browser.close()\n        if self.playwright:\n            await self.playwright.stop()\n\n    async def goto(self, url: str) -> None:\n        \"\"\"Navigate to URL\"\"\"\n        await self.page.goto(url)\n\n    async def wait_for_selector(self, selector: str, timeout: Optional[int] = None) -> None:\n        \"\"\"Wait for element to appear\"\"\"\n        await self.page.wait_for_selector(selector, timeout=timeout or self.config.timeout)\n\n    async def click(self, selector: str) -> None:\n        \"\"\"Click an element\"\"\"\n        await self.page.click(selector)\n\n    async def type_text(self, selector: str, text: str) -> None:\n        \"\"\"Type text into an input\"\"\"\n        await self.page.fill(selector, text)\n\n    async def get_text(self, selector: str) -> str:\n        \"\"\"Get text content from element\"\"\"\n        return await self.page.text_content(selector)\n\n    async def get_all_text(self, selector: str) -> List[str]:\n        \"\"\"Get all text contents matching selector\"\"\"\n        elements = await self.page.query_selector_all(selector)\n        return [await el.text_content() for el in elements]\n\n    async def press_key(self, key: str) -> None:\n        \"\"\"Press a keyboard key\"\"\"\n        await self.page.press(\"body\", key)\n\n    async def wait_for_load_state(self, state: str = \"networkidle\") -> None:\n        \"\"\"Wait for page to reach certain state\"\"\"\n        await self.page.wait_for_load_state(state)\n\n    async def scroll_to_bottom(self) -> None:\n        \"\"\"Scroll to bottom of page\"\"\"\n        await self.page.evaluate(\"window.scrollTo(0, document.body.scrollHeight)\")\n\n    async def scroll_to_top(self) -> None:\n        \"\"\"Scroll to top of page\"\"\"\n        await self.page.evaluate(\"window.scrollTo(0, 0)\")\n\n    @abstractmethod\n    async def login(self) -> bool:\n        \"\"\"Handle login - override in subclasses\"\"\"\n        pass\n\n    @abstractmethod\n    async def is_logged_in(self) -> bool:\n        \"\"\"Check if logged in - override in subclasses\"\"\"\n        pass\n\n    async def __aenter__(self):\n        await self.start()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        await self.stop()\n\n```\n\nPlease provide:\n1. CRITICAL issues (bugs, security risks) - must fix\n2. MAJOR improvements (architecture, error handling) - should fix  \n3. MINOR suggestions (style, best practices) - nice to have\n\nFor each issue, include:\n- Line number(s)\n- Current code\n- Suggested fix with code\n- Brief explanation of why",
      "timestamp": "2026-02-10T12:38:17.911127"
    },
    {
      "role": "assistant",
      "content": "Failed to send message",
      "timestamp": "2026-02-10T12:38:27.693458"
    },
    {
      "role": "user",
      "content": "Please review this file: chatgpt.py\n\nContext: ChatGPT-specific automation\n\n```python\n\"\"\"\nChatGPT-specific automation module\n\"\"\"\n\nimport asyncio\nfrom typing import Optional, List, Dict, Any\nfrom datetime import datetime\n\nfrom .base import BrowserAutomation\nfrom .config import ChatAutomationConfig\n\n\nclass ChatGPTAutomation(BrowserAutomation):\n    \"\"\"Automation for ChatGPT web interface\"\"\"\n\n    def __init__(self, config: Optional[ChatAutomationConfig] = None):\n        super().__init__(config)\n\n    async def setup_popup_handler(self):\n        \"\"\"Handle dialogs/popups automatically\"\"\"\n        self.page.on(\"dialog\", lambda dialog: dialog.accept())\n\n    async def login(self) -> bool:\n        \"\"\"Navigate to login page and wait for user interaction\"\"\"\n        await self.goto(self.config.chatgpt_url)\n        await self.wait_for_load_state(\"networkidle\")\n        return True\n\n    async def is_logged_in(self) -> bool:\n        \"\"\"Check if logged into ChatGPT\"\"\"\n        try:\n            await self.page.wait_for_selector(\"[data-testid='user-button'], [data-testid='login-button']\", timeout=5000)\n            login_btn = await self.page.query_selector(\"[data-testid='login-button']\")\n            return login_btn is None\n        except:\n            return False\n\n    async def find_textarea(self):\n        \"\"\"Find the chat input (contenteditable div or textarea)\"\"\"\n        # After first message, interface changes - try multiple selectors\n        selectors = [\n            '#prompt-textarea[contenteditable=\"true\"]',  # Main input\n            'div[contenteditable=\"true\"]',  # Contenteditable fallback\n            'textarea[name=\"prompt-textarea\"]',  # Textarea fallback\n            '[data-testid=\"chat-input\"]',  # Test ID\n            'div[id=\"prompt-textarea\"]',  # ID only (in conversation view)\n            '.ProseMirror',  # ProseMirror editor class\n            '[class*=\"prompt-textarea\"]',  # Class contains\n        ]\n\n        for selector in selectors:\n            try:\n                element = await self.page.query_selector(selector)\n                if element:\n                    # Check if it's actually editable\n                    try:\n                        is_editable = await element.is_editable()\n                        if is_editable:\n                            return element\n                    except:\n                        # If we can't check, return it anyway\n                        return element\n            except:\n                continue\n        return None\n\n    async def find_send_button(self):\n        \"\"\"Find the send/submit button\"\"\"\n        selectors = [\n            '#composer-submit-button',  # ID selector\n            '[data-testid=\"send-button\"]',  # Test ID\n            'button[type=\"submit\"]',  # Submit button\n            '[aria-label*=\"Send\"]',  # English\n            '[aria-label*=\"Envoyer\"]',  # French\n            'button.composer-submit-btn',  # Class-based\n            'button svg[class*=\"send\"]',  # SVG-based\n            'button:has(svg)',  # Has SVG icon\n            'button[class*=\"submit\"]',  # Class contains submit\n            'button[class*=\"primary\"]',  # Primary action button\n        ]\n\n        for selector in selectors:\n            try:\n                btn = await self.page.query_selector(selector)\n                if btn:\n                    # Check if visible and enabled\n                    try:\n                        visible = await btn.is_visible()\n                        enabled = await btn.is_enabled()\n                        if visible and enabled:\n                            return btn\n                    except:\n                        # If we can't check, return it anyway\n                        return btn\n            except:\n                continue\n        return None\n\n    async def wait_for_ready(self) -> None:\n        \"\"\"Wait for ChatGPT interface to be ready\"\"\"\n        await asyncio.sleep(2)\n        textarea = await self.find_textarea()\n        if textarea:\n            await asyncio.sleep(1)\n        else:\n            await asyncio.sleep(3)\n\n    async def start_new_chat(self) -> None:\n        \"\"\"Start a new chat conversation\"\"\"\n        try:\n            new_chat_btn = await self.page.query_selector(\"[data-testid='new-chat-button'], button:has-text('New chat')\")\n            if new_chat_btn:\n                await new_chat_btn.click()\n                await asyncio.sleep(1)\n        except Exception as e:\n            print(f\"New chat button not found: {e}\")\n\n    async def send_message(self, message: str, max_retries: int = 3) -> bool:\n        \"\"\"Send a message to ChatGPT\"\"\"\n        for attempt in range(max_retries):\n            try:\n                # Find the input element\n                element = await self.find_textarea()\n                if not element:\n                    print(f\"Attempt {attempt + 1}: Could not find chat input!\")\n                    await asyncio.sleep(2)\n                    continue\n\n                # Try page-level fill with selector first (more robust)\n                fill_success = False\n                selectors = [\n                    '#prompt-textarea',\n                    'div[contenteditable=\"true\"]',\n                    'textarea[name=\"prompt-textarea\"]'\n                ]\n                \n                for selector in selectors:\n                    try:\n                        await self.page.fill(selector, message, timeout=5000)\n                        print(f\"Filled input via page.fill(): {message}\")\n                        fill_success = True\n                        break\n                    except Exception as fill_err:\n                        continue\n                \n                if not fill_success:\n                    # Fallback to element-level fill\n                    await element.fill(message)\n                    print(f\"Filled input via element.fill(): {message}\")\n                \n                await asyncio.sleep(0.5)\n\n                # Find and click send button\n                send_btn = await self.find_send_button()\n                if send_btn:\n                    try:\n                        await send_btn.click()\n                        print(f\"Sent message via button: {message}\")\n                        return True\n                    except Exception as click_err:\n                        print(f\"Button click failed: {click_err}, trying Enter key...\")\n                        # Fallback to Enter key\n                        await element.press(\"Enter\")\n                        print(f\"Sent message via Enter: {message}\")\n                        return True\n                else:\n                    # No button found, try Enter key\n                    print(f\"Send button not found, using Enter key...\")\n                    await element.press(\"Enter\")\n                    print(f\"Sent message via Enter: {message}\")\n                    return True\n\n            except Exception as e:\n                print(f\"Attempt {attempt + 1} error sending message: {e}\")\n                if attempt < max_retries - 1:\n                    await asyncio.sleep(3)\n                continue\n\n        print(\"Failed to send message after all retries\")\n        return False\n\n    async def attach_file(self, filepath: str, message: str = \"\") -> bool:\n        \"\"\"Attach a file to the conversation using file upload\n        \n        Args:\n            filepath: Path to the file to upload\n            message: Optional message to send with the file\n        \"\"\"\n        try:\n            # Find the attach file button\n            attach_selectors = [\n                'button[data-testid=\"attach-file-button\"]',\n                'button[aria-label*=\"Attach\"]',\n                'button[aria-label*=\"Attach file\"]',\n                'button svg[class*=\"attach\"]',\n                'button svg[class*=\"paperclip\"]',\n                'button:has(svg[class*=\"attach\"])',\n                'button:has(svg[class*=\"paperclip\"])',\n            ]\n            \n            attach_btn = None\n            for selector in attach_selectors:\n                try:\n                    btn = await self.page.query_selector(selector)\n                    if btn:\n                        visible = await btn.is_visible()\n                        if visible:\n                            attach_btn = btn\n                            break\n                except:\n                    continue\n            \n            if not attach_btn:\n                print(\"Attach file button not found, trying file input directly...\")\n                # Try to find file input directly\n                file_input = await self.page.query_selector('input[type=\"file\"]')\n                if file_input:\n                    await file_input.set_input_files(filepath)\n                    print(f\"Attached file: {filepath}\")\n                    \n                    # Wait a moment for upload\n                    await asyncio.sleep(2)\n                    \n                    # Send message if provided\n                    if message:\n                        await self.send_message(message)\n                    else:\n                        # Just click send button\n                        send_btn = await self.find_send_button()\n                        if send_btn:\n                            await send_btn.click()\n                            print(\"Sent file\")\n                    return True\n                else:\n                    print(\"No file input found\")\n                    return False\n            \n            # Click attach button\n            await attach_btn.click()\n            print(\"Clicked attach button\")\n            await asyncio.sleep(1)\n            \n            # Find file input that should now be visible\n            file_input = await self.page.query_selector('input[type=\"file\"]')\n            if file_input:\n                await file_input.set_input_files(filepath)\n                print(f\"Attached file: {filepath}\")\n                \n                # Wait for upload\n                await asyncio.sleep(2)\n                \n                # Send message if provided\n                if message:\n                    await self.send_message(message)\n                else:\n                    # Click send\n                    send_btn = await self.find_send_button()\n                    if send_btn:\n                        await send_btn.click()\n                        print(\"Sent file\")\n                \n                return True\n            else:\n                print(\"File input not found after clicking attach\")\n                return False\n                \n        except Exception as e:\n            print(f\"Error attaching file: {e}\")\n            return False\n\n    async def wait_for_response(self, timeout: int = 120000) -> bool:\n        \"\"\"Wait for ChatGPT to finish generating response and input to be ready\"\"\"\n        try:\n            for _ in range(timeout // 2000):\n                await asyncio.sleep(2)\n\n                stop_btn = await self.page.query_selector(\"[data-testid='stop-button'], [aria-label='Stop generating']\")\n                if stop_btn and await stop_btn.is_visible():\n                    continue\n\n                textarea = await self.find_textarea()\n                if textarea:\n                    enabled = await textarea.is_enabled()\n                    if enabled:\n                        return True\n\n            return False\n        except Exception as e:\n            print(f\"Error waiting for response: {e}\")\n            return False\n\n    async def get_last_response(self) -> str:\n        \"\"\"Get the last response from ChatGPT\"\"\"\n        try:\n            await self.scroll_to_bottom()\n            await asyncio.sleep(1)\n\n            responses = await self.page.query_selector_all('[data-message-id], .assistant-content, .markdown, .prose')\n\n            if responses:\n                last = responses[-1]\n                text = await last.text_content()\n                return text or \"\"\n        except Exception as e:\n            print(f\"Error getting response: {e}\")\n        return \"\"\n\n    async def get_conversation_history(self) -> List[Dict[str, str]]:\n        \"\"\"Get all messages in current conversation\"\"\"\n        messages = []\n        try:\n            user_msgs = await self.page.query_selector_all(\"[data-testid='conversation-turn:user'], .user-message, .human-message\")\n            assistant_msgs = await self.page.query_selector_all(\"[data-testid='conversation-turn:assistant'], .assistant-message, .ai-message\")\n\n            for i, (user, assistant) in enumerate(zip(user_msgs, assistant_msgs)):\n                user_text = (await user.text_content()) or \"\"\n                assistant_text = (await assistant.text_content()) or \"\"\n                messages.append({\"role\": \"user\", \"content\": user_text})\n                if assistant_text:\n                    messages.append({\"role\": \"assistant\", \"content\": assistant_text})\n        except Exception as e:\n            print(f\"Error getting history: {e}\")\n        return messages\n\n    async def list_conversations(self, limit: int = 20) -> List[Dict[str, Any]]:\n        \"\"\"List recent conversations from sidebar\"\"\"\n        await self.goto(self.config.chatgpt_url)\n        await asyncio.sleep(2)\n\n        conversations = []\n        try:\n            conv_items = await self.page.query_selector_all(\"[data-testid='conversation-item'], .conversation-item, [class*='conversation']\")[:limit]\n\n            for item in conv_items:\n                try:\n                    title_elem = await item.query_selector(\".title, [data-testid='conversation-title'], [class*='title']\")\n                    date_elem = await item.query_selector(\".date, [data-testid='conversation-date'], [class*='date']\")\n                    title = (await title_elem.text_content()) if title_elem else \"Untitled\"\n                    date = (await date_elem.text_content()) if date_elem else \"\"\n\n                    conversations.append({\n                        \"title\": title.strip() if title else \"Untitled\",\n                        \"date\": date.strip() if date else \"\",\n                        \"element\": item\n                    })\n                except Exception as e:\n                    print(f\"Error parsing conversation item: {e}\")\n        except Exception as e:\n            print(f\"Error listing conversations: {e}\")\n        return conversations\n\n    async def open_conversation(self, title: str) -> bool:\n        \"\"\"Open a specific conversation by title\"\"\"\n        conversations = await self.list_conversations()\n        for conv in conversations:\n            if title.lower() in conv[\"title\"].lower():\n                await conv[\"element\"].click()\n                await self.wait_for_ready()\n                return True\n        return False\n\n    async def chat(self, message: str, wait_for_response: bool = True) -> str:\n        \"\"\"Send message and return response\"\"\"\n        success = await self.send_message(message)\n        if not success:\n            return \"Failed to send message\"\n\n        if wait_for_response:\n            print(\"Waiting for response...\")\n            ready = await self.wait_for_response()\n            if not ready:\n                return \"Response timed out\"\n            await asyncio.sleep(1)\n\n        return await self.get_last_response()\n\n```\n\nPlease provide:\n1. CRITICAL issues (bugs, security risks) - must fix\n2. MAJOR improvements (architecture, error handling) - should fix  \n3. MINOR suggestions (style, best practices) - nice to have\n\nFor each issue, include:\n- Line number(s)\n- Current code\n- Suggested fix with code\n- Brief explanation of why",
      "timestamp": "2026-02-10T12:38:27.750318"
    },
    {
      "role": "assistant",
      "content": "Failed to send message",
      "timestamp": "2026-02-10T12:38:34.879563"
    },
    {
      "role": "user",
      "content": "Please review this file: config.py\n\nContext: Configuration classes\n\n```python\n\"\"\"\nConfiguration for chat automation\n\"\"\"\n\nimport os\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n\n@dataclass\nclass ChatAutomationConfig:\n    \"\"\"Configuration for chat automation\"\"\"\n    headless: bool = False\n    browser_type: str = \"chromium\"\n    browser_channel: Optional[str] = None\n    browser_executable_path: Optional[str] = None\n    browser_args: Optional[list] = None\n    timeout: int = 30000\n    user_data_dir: Optional[str] = None\n\n    chatgpt_url: str = \"https://chatgpt.com\"\n    claude_url: str = \"https://claude.ai\"\n    deepseek_url: str = \"https://chat.deepseek.com\"\n\n    @classmethod\n    def brave(cls, profile_directory: Optional[str] = None, user_data_dir: Optional[str] = None) -> \"ChatAutomationConfig\":\n        \"\"\"Create config for Brave browser\"\"\"\n        browser_args = None\n        browser_channel = \"brave\"\n        executable_path = \"/usr/bin/brave-browser\"\n\n        if user_data_dir:\n            browser_args = [f\"--profile-directory=Automation Profile\"]\n        elif profile_directory:\n            browser_args = [f\"--profile-directory={profile_directory}\"]\n\n        return cls(\n            headless=False,\n            browser_type=\"chromium\",\n            browser_channel=browser_channel,\n            browser_executable_path=executable_path,\n            browser_args=browser_args,\n            timeout=60000,\n            user_data_dir=user_data_dir,\n        )\n\n    @classmethod\n    def brave_automation(cls) -> \"ChatAutomationConfig\":\n        \"\"\"Create config for Brave browser with separate automation profile\"\"\"\n        automation_dir = os.path.expanduser(\"~/.config/BraveSoftware/Brave-Automation\")\n        os.makedirs(automation_dir, exist_ok=True)\n\n        return cls(\n            headless=False,\n            browser_type=\"chromium\",\n            browser_channel=\"brave\",\n            browser_executable_path=\"/usr/bin/brave-browser\",\n            timeout=60000,\n            user_data_dir=automation_dir,\n        )\n\n    @classmethod\n    def chromium(cls, user_data_dir: Optional[str] = None) -> \"ChatAutomationConfig\":\n        \"\"\"Create config for Chromium browser\"\"\"\n        return cls(\n            headless=False,\n            browser_type=\"chromium\",\n            browser_channel=\"chromium\",\n            timeout=60000,\n            user_data_dir=user_data_dir,\n        )\n\n    @classmethod\n    def from_env(cls) -> \"ChatAutomationConfig\":\n        \"\"\"Load config from environment variables\"\"\"\n        browser = os.getenv(\"CHAT_AUTO_BROWSER\", \"chromium\").lower()\n        if browser == \"brave\":\n            return cls.brave(os.getenv(\"CHAT_AUTO_USER_DATA\", None))\n        return cls.chromium(os.getenv(\"CHAT_AUTO_USER_DATA\", None))\n\n\nDEFAULT_CONFIG = ChatAutomationConfig()\n\n```\n\nPlease provide:\n1. CRITICAL issues (bugs, security risks) - must fix\n2. MAJOR improvements (architecture, error handling) - should fix  \n3. MINOR suggestions (style, best practices) - nice to have\n\nFor each issue, include:\n- Line number(s)\n- Current code\n- Suggested fix with code\n- Brief explanation of why",
      "timestamp": "2026-02-10T12:38:35.463551"
    },
    {
      "role": "assistant",
      "content": "Failed to send message",
      "timestamp": "2026-02-10T12:38:41.899508"
    },
    {
      "role": "user",
      "content": "Based on all the files reviewed, provide:\n\nPRIORITY 1 - Fix Immediately (Critical bugs/security):\n- List the top 3 most critical issues\n\nPRIORITY 2 - Should Fix (Major improvements):\n- List 3-5 important improvements\n\nPRIORITY 3 - Nice to Have (Minor enhancements):\n- List minor suggestions\n\nREFACTORING ROADMAP:\nWhat order should I tackle these improvements in?",
      "timestamp": "2026-02-10T12:38:42.557815"
    },
    {
      "role": "assistant",
      "content": "Failed to send message",
      "timestamp": "2026-02-10T12:38:49.082513"
    }
  ]
}