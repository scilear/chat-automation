#!/usr/bin/env python3
"""
Browser Daemon - Keeps browser running for instant CLI access
Shared between ChatGPT and Perplexity CLIs

Usage:
    ./browser-daemon start    # Start daemon (run once)
    ./browser-daemon stop     # Stop daemon  
    ./browser-daemon status   # Check if running
"""

import asyncio
import sys
import os
import json
import signal
import subprocess
from pathlib import Path
from datetime import datetime

# Paths
PID_FILE = Path.home() / ".chat_automation" / "browser_daemon.pid"
CDP_FILE = Path.home() / ".chat_automation" / "browser_cdp.json"
LOG_FILE = Path.home() / ".chat_automation" / "browser_daemon.log"

# CDP port
CDP_PORT = 9222

def log(msg):
    """Log to file"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    with open(LOG_FILE, 'a') as f:
        f.write(f"[{timestamp}] {msg}\n")

def is_running(pid):
    """Check if process is running"""
    try:
        os.kill(pid, 0)
        return True
    except:
        return False

def get_daemon_pid():
    """Get daemon PID if running"""
    if PID_FILE.exists():
        try:
            with open(PID_FILE) as f:
                return int(f.read().strip())
        except:
            pass
    return None

async def run_daemon():
    """Main daemon loop - keeps browser alive"""
    sys.path.insert(0, '/home/fabien/clawd')
    from playwright.async_api import async_playwright
    
    print("Daemon: Starting...", flush=True)
    
    try:
        print("Daemon: Starting playwright...", flush=True)
        playwright = await async_playwright().start()
        
        # Launch browser with CDP
        user_data_dir = Path.home() / ".config/BraveSoftware/Brave-Automation"
        print(f"Daemon: Launching browser...", flush=True)
        
        browser = await asyncio.wait_for(
            playwright.chromium.launch_persistent_context(
                user_data_dir=str(user_data_dir),
                headless=False,
                viewport={"width": 1280, "height": 800},
                args=[
                    "--disable-blink-features=AutomationControlled",
                    "--disable-automation",
                    f"--remote-debugging-port={CDP_PORT}",
                    "--no-sandbox",
                ],
            ),
            timeout=30
        )
        
        print("Daemon: Browser launched successfully!", flush=True)
        
        # Get the page
        page = browser.pages[0] if browser.pages else await browser.new_page()
        
        # Save CDP endpoint
        cdp_endpoint = f"http://127.0.0.1:{CDP_PORT}"
        CDP_FILE.parent.mkdir(parents=True, exist_ok=True)
        with open(CDP_FILE, 'w') as f:
            json.dump({'endpoint': cdp_endpoint, 'pid': os.getpid()}, f)
        
        # Save PID
        with open(PID_FILE, 'w') as f:
            f.write(str(os.getpid()))
        
        print(f"Daemon: Ready. PID: {os.getpid()}", flush=True)
        print(f"✓ Browser daemon started (PID: {os.getpid()})")
        print(f"✓ Browser running with CDP on port {CDP_PORT}")
        print("\nYou can now use:")
        print("  ./chatgpt chat \"Hello\"      # Fast ChatGPT access")
        print("  ./perplexity chat \"Hello\"   # Fast Perplexity access")
        print("  ./browser-daemon status      # Check status")
        print("  ./browser-daemon stop        # Stop daemon")
        
        # Keep alive
        while True:
            await asyncio.sleep(60)
            
    except Exception as e:
        log(f"Daemon error: {e}")
        print(f"✗ Error: {e}")
    finally:
        log("Daemon stopping...")
        if 'browser' in locals():
            await browser.close()
        if 'playwright' in locals():
            await playwright.stop()
        PID_FILE.unlink(missing_ok=True)
        CDP_FILE.unlink(missing_ok=True)

def start_daemon():
    """Start daemon in background"""
    pid = get_daemon_pid()
    if pid and is_running(pid):
        print(f"Daemon already running (PID: {pid})")
        print(f"CDP endpoint: http://127.0.0.1:{CDP_PORT}")
        return
    
    # Clear old PID file
    PID_FILE.unlink(missing_ok=True)
    
    # Start daemon using setsid to create new session
    import subprocess
    import os
    
    # Use venv python if available
    venv_python = Path(__file__).parent / ".venv" / "bin" / "python3"
    if venv_python.exists():
        python_executable = str(venv_python)
    else:
        python_executable = sys.executable
    
    daemon_cmd = [python_executable, __file__, "run"]
    
    # Use setsid to create new session, redirect outputs
    subprocess.Popen(
        ['setsid'] + daemon_cmd,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
        start_new_session=True,
    )
    
    # Wait for daemon to be ready (up to 30 seconds)
    import time
    for i in range(60):
        time.sleep(0.5)
        pid = get_daemon_pid()
        if pid and is_running(pid):
            # Check CDP is responding
            try:
                import urllib.request
                with urllib.request.urlopen(f"http://127.0.0.1:{CDP_PORT}/json", timeout=1) as response:
                    if response.status == 200:
                        print(f"✓ Daemon started (PID: {pid})")
                        print(f"✓ Browser ready on CDP port {CDP_PORT}")
                        return
            except:
                pass
    
    print("✗ Daemon failed to start")

def stop_daemon():
    """Stop the daemon"""
    pid = get_daemon_pid()
    if not pid:
        print("Daemon not running")
        return
    
    if not is_running(pid):
        print("Daemon not running (stale PID file)")
        PID_FILE.unlink(missing_ok=True)
        return
    
    try:
        os.kill(pid, signal.SIGTERM)
        import time
        for i in range(10):
            time.sleep(0.5)
            if not is_running(pid):
                print("✓ Daemon stopped")
                return
        # Force kill
        os.kill(pid, signal.SIGKILL)
        print("✓ Daemon stopped (forced)")
    except ProcessLookupError:
        print("Daemon not running")
    finally:
        PID_FILE.unlink(missing_ok=True)
        CDP_FILE.unlink(missing_ok=True)

def status_daemon():
    """Check daemon status"""
    pid = get_daemon_pid()
    if pid and is_running(pid):
        print(f"✓ Daemon running (PID: {pid})")
        print(f"✓ CDP endpoint: http://127.0.0.1:{CDP_PORT}")
        
        # Check CDP is responding
        import urllib.request
        try:
            with urllib.request.urlopen(f"http://127.0.0.1:{CDP_PORT}/json", timeout=2) as response:
                if response.status == 200:
                    print("✓ Browser responding on CDP port")
                else:
                    print("⚠ Browser not responding correctly")
        except Exception as e:
            print(f"⚠ Cannot connect to browser: {e}")
    else:
        print("✗ Daemon not running")
        print(f"  Start with: {sys.argv[0]} start")

def main():
    if len(sys.argv) < 2:
        print("Usage:")
        print(f"  {sys.argv[0]} start    # Start daemon")
        print(f"  {sys.argv[0]} stop     # Stop daemon")
        print(f"  {sys.argv[0]} status   # Check status")
        print(f"  {sys.argv[0]} run      # Run daemon in foreground (internal)")
        return
    
    cmd = sys.argv[1]
    if cmd == "start":
        start_daemon()
    elif cmd == "stop":
        stop_daemon()
    elif cmd == "status":
        status_daemon()
    elif cmd == "run":
        asyncio.run(run_daemon())
    else:
        print(f"Unknown command: {cmd}")
        print("Use: start, stop, status")

if __name__ == "__main__":
    main()
